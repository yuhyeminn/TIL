# 💣day6 (2021/01/20)

<br>

## ✨ 트랜잭션(Transaction)

>https://coding-factory.tistory.com/226

<br>

### 트랜잭션(Transaction) 이란?

`트랜잭션(Transaction)`이란 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위를 구성하는 연산들의 집합을 뜻한다.

<br>

### 트랜잭션의 성질 4가지

- **원자성 (Atomicity)**
  - 트랜잭션의 연산은 데이터베이스에 모두 반영되거나 전혀 반영되지 않아야 함
  - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 함
- **일관성 (Consistency)**
  - 트랜잭션이 성공적으로 작업을 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환함
  - 시스템이 가지고 있는 고정 요소는 트랜잭션 수행 전과 완료 후 상태가 같아야 함
- **독립성 (Isolation)**
  - 둘 이상의 트랜잭션이 병행 실행되는 경우 실행중인 트랜잭션이 완료될 때 까지 다른 트랜잭션이 참조할 수 없음
  - 수행중인 트랜잭션은 완전히 완료할 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음

- **지속성 (Durability) **
  - 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함

<br>

### 트랜잭션의 Commit, Rollback 연산

트랜잭션의 `Commit` 연산은 트랜잭션의 작업이 성공적으로 끝나고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산이다.

`Rollback`연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸으 ㄹ때, 이 트랜잭션 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소하는 연산이다.

<br>

### 트랜잭션의 상태

- `활동(Active)` : 트랜잭션이 실행중인 상태
- `실패(Failed)` : 트랜잭셔 실행에 오류가 발생하여 중단된 상태
- `철회(Aborted)` : 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
- `부분 완료(Partially Committed)` : 트랜잭션의 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태
- `완료(Committed)` : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

<br>

## ✨ MVC패턴의 모델 VO/DTO/DAO/BO

> https://berrrrr.github.io/programming/2019/11/03/dao-vo-do-dto/

### DAO(Data Access Object)

`DAO`는 데이터 사용 기능 담당 클래스이다. Database 접근을 하기 위한 로직과 비즈니스 로직을 분리하기 위해 사용한다. 때문에 DB Connection 로직까지 설정되어 있는 경우가 많고 DB를 이용해 데이터를 CRUD하는 기능을 전담한다.

<br>

### DTO(Data Transfer Object)

`DTO`는 Controller, Service, View 등 계층간 데이터 교환을 위해 사용되는 객체이다. 로직을 갖지 않는 순수한 데이터 객체이며 getter, setter 메소드만을 포함하고 가변의 성격을 가진다.

<br>

### VO(Value Object)

`VO`도 `DTO`와 같이 데이터 저장 담당 클래스이다. VO는 DTO와는 다르게 값(Value)을 위해 쓰이는 개체로 불변(read only)의 속성을 가진다. 보통 getter의 기능만을 포함한다.

<br>

### BO(Business Object)

비즈니스 객체란, 객체 지향 프로그램에서 Domain 내 Entity들을 추상화하는 객체이다. 때로는 도메인 객체라고 불리기도 한다. 이 때 도메인 모델은 여러 도메인 객체와 그들간의 관계로 표현될 수 있다.

비즈니스 로직을 포함하는 오브젝트이다. VO인데 비즈니스 관련 내용을 담은 VO라고 보면 된다.

<br>

## ✨ 배열과 리스트

> https://velog.io/@choiiis/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B0%B0%EC%97%B4Array%EA%B3%BC-%EB%A6%AC%EC%8A%A4%ED%8A%B8List
>
> https://velog.io/@adam2/Array%EC%99%80-List%EA%B7%B8%EB%A6%AC%EA%B3%A0-Java-List

<br>

### 배열

- 같은 타입의 데이터를 나열한 선형 자료구조 (sequence container)
- 연속된 메모리 공간에 순차적으로 저장함
- 배열의 크기는 고정됨. 선언할 때 배열의 크기를 정하고 변경할 수 없음
- 장점
  - 인덱스를 가지고 있어서 바로 접근이 가능하다 $O(1)$
    - 배열에서의 인덱스는 값에 대한 유일무이한 식별자 역할을 함
  - 연속된 메모리 공간에 존재하기 때문에 관리하기 편함
- 단점
  - 원소를 삽입하거나 삭제할 경우 해당 원소 이후 모든 원소들을 한칸 씩 밀거나 당겨야 하기 때문에 삽입과 삭제가 어렵고 오래걸림
  - 배열의 크기를 바꿀 수 없음
    - 크기가 고정되어 있기 때문에 어떤 엘리먼트가 삭제되면, 삭제된 상태를 빈 공간으로 남겨두어야 한다. => `메모리 낭비`
  - 연속적인 메모리 할당이 필요해 메모리 공간을 많이 사용하게 될 수 있음
- 데이터의 크기가 정해져 있고, 추가적인 삽입 삭제가 일어 나지 않으며 검색을 필요로 할 때 유리함

<br>

### 리스트

- 데이터를 순차적으로 저장하는 선형 자료구조
- 불 연속적 메모리 공간에 저장함
- 리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고 대신 **빈틈없는 데이터의 적재** 라는 장점을 취함
- 크기가 고정되어 있지 않아 크기 제한에서 자유로움
- 인덱스 접근이 불가함
  - 리스트에서 인덱스는 몇번째 데이터인가 정도의 의미를 가짐.
- 장점
  - 삽입과 삭제가 용이함
  - 크기가 정해져있지 않고 동적으로 생성함
  - 연속적인 메모리 할당이 필요하지 않고 사용한 메모리는 재사용이 가능함
- 단점
  - 원소를 탐색할 때 임의 접근이 불가능하여 반복자를 이용하여 탐색해야 함
  - 포인터로 인해 저장 공간의 낭비가 발생함
- 데이터의 크기가 정해져 있지 않고, 삽입 삭제가 많이 일어나며, 검색이 적은 경우 유리함

<br>

## ✨ ArrayList, LinkedList, Vector

> https://www.holaxprogramming.com/2014/02/12/java-list-interface/

<br>

자바에서의 List는 Collection 인터페이스를 확장한 자료형으로 동일한 데이터의 중복 입력이 가능하며 순차적이고 다량의 데이터를 입력할 때 주로 사용한다. 종류는 Vector, Arraylist, Linkedlist가 있다.

<br>

### ArrayList

`ArrayList`는 내부적으로 데이터를 배열에서 관리하며 데이터의 추가, 삭제를 위해 임시 배열을 생성해 데이터를 복사 하는 방법을 사용 하고 있다. 대량의 자료를 추가/삭제 하는 경우에는 그만큼 데이터의 복사가 많이 일어나게 되어 성능 저하를 일으킬 수 있다. 반면 각 데이터는 인덱스를 가지고 있기 때문에 한번에 참조가 가능해 데이터의 검색에는 유리한 구현체이다. `ArrayList`는 **대용량 데이터를 한 번에 가져와서 여러번 참조해 사용할 때 최상의 성능**을 내는 객체다. 

<br>

### Vector

`Vector`는 ArrayList와 동일하게 사용가능 하며 ArrayList와 달리 동기화를 해준다. 즉, 데이터 동시 접속이 발생했을 시 처리 능력이 있다. 하지만 싱글 스레드 환경이어도 동기화처리를 하기 때문에 성능이 좋지 않아 잘 쓰이지 않는다. ArrayList는 비동기화지만 Vector보다 가볍고 속도가 빠르다는 장점이 있다.

<br>

### LinkedList

`LinkedList`는 노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가진 연결 리스트 자료구조이다. 연결된 자료의 정보만 담고 있기 때문에 중간 노드에 추가/삭제시 다른 데이터의 위치를 변경시킬 필요없이 간단하게 추가/삭제할 수 있다. 삽입과 삭제가 빠르지만 탐색이 느리다는 단점이 있다. 추가/삭제가 빈번하게 일어나는 대용량 데이터 처리가 필요할 때 사용하면 성능이 좋다.

