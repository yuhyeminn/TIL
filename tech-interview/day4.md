# 💣day4 (2021/01/18)

<br>

## ✨ 프로세스와 스레드

>https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html
>
>https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4
>
>https://devuna.tistory.com/21

<br>

- 프로그램 : 파일이 저장 장치에 저장되어 있지만 메모리에는 올라가 있지 않은 정적인 상태
- 프로세스 : 운영체제로부터 자원을 할당받은 작업의 단위
- 스레드 : 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위

<br>

### 프로세스(Process)

프로세스란 **컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램**으로 정의할 수 있으며, 프로그램을 실행하는 순간 해당 파일이 컴퓨터 메모리에 올라가게 되는데 이 상태의 프로그램을 **프로세스**라고 한다.

프로세스는 운영체제로부터 각각의 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받기 때문에 한 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없다. 다른 프로세스의 자원에 접근하려면 프로세스 간의 통신 (IPC, inter-process-communication)을 사용할 수 있지만 자원 부담이 크다.

![img](https://gmlwjd9405.github.io/images/os-process-and-thread/process.png)

- 프로세스의 메모리 영역
  - Code : 코드 자체를 구성하는 메모리 영역 (프로그램 명령)
  - Data : 전역변수, 정적 변수, 배열 등 (초기화된 데이터)
  - Stack : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
  - Heap : 동적 할당 시 사용(new(), mallock() 등)

<br>

### 스레드(Thread)

스레드란 **프로세스 내에서 실행되는 여러 흐름의 단위**이며 프로세스의 코드에 정의된 절차에 따라 실행되는 특정한 수행 경로이다. 

스레드는 프로세스 내에서 각각 Stack만 할당 받고 Code, Data, Heap 영역은 공유한다. 이와 같은 이유로 스레드는 프로세스와 달리 프로세스 내의 주소공간이나 자원들을 스레드끼리 공유하며 실행된다. 그래서 한 스레드가 프로세스 자원을 변경하면 다른 이웃 스레드도 그 변경 결과를 즉시 볼 수 있다.

![img](https://gmlwjd9405.github.io/images/os-process-and-thread/multi-thread.png)

- 왜 스택만 분리해서 사용할까?
  - 스택의 후입선출(LIFO)이라는 특성과 연관이 있다. 스택이 쌓이면 위에서부터 프로세스가 섞인 채로 순서대로 나오게 되어 더 복잡해지기 때문에 원활한 실행 흐름을 위해 스택은 독립적으로 존재하게 된다.

<br>

### 자바 스레드(Java Thread) 

자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다. 일반 스레드와 거의 차이가 없으며 JVM이 운영체제의 역할을 하여 스레드 스케줄링과 스레드 정보에 대한 관리도 JVM이 수행한다.



### 프로세스와 스레드의 차이

프로세스는 최소 하나 이상의 스레드를 포함하기 때문에 프로세스와 스레드는 개념의 범위부터 다르다.

운영체제 관점에서는 프로세스가 최소 작업 단위가 되며, CPU 관점에서는 스레드가 최소 작업 단위가 된다. 프로세스는 다른 프로세스와 정보를 공유하려면 IPC를 사용하는 등의 번거로운 과정을 거쳐야 하지만, 스레드는 기본 구조 자체가 메모리를 공유하는 구조이기 때문에 다른 스레드와 정보 공유가 쉽다. 

프로세스를 실행하다가 오류가 발생해서 프로세스가 강제로 종료된다면, 다른 프로세스에게 영향을 주지 않는다. 반면에 스레드의 경우는 일부 메모리영역을 공유하고 있기 때문에 어떤 스레드 하나에서 오류가 발생한다면 같은 프로세스 내의 다른 스레드 모두가 강제로 종료된다.

<br>

## ✨ 멀티 프로세스와 멀티 스레드

> https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html
>
> https://velog.io/@raejoonee/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4

<br>

### 멀티 프로세스

멀티 프로세싱이란 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다. 

멀티 프로세싱을 할 경우 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 다른 프로세스에게 영향이 확산되지 않는다는 장점이 있다. 그러나 현재 작업의 상태를 저장하고 다음 진행할 작업의 상태값을 읽어 적용하는 `Context-Switching` 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생하게 된다. 프로세스는 각각의 독립된 메모리 영역을 할당받았기 때문에 프로세스 간 공유하는 메모리가 없어, `Context-Switching`이 발생하면 캐시에 있는 모든 데이터를 리셋하고 다시 캐시 정보를 불러와야 하기 때문이다.

<br>

### 멀티 스레드

멀티 스레딩이란 하나의 프로세스가 여러 작업을  여러 개의 스레드를 사용하여 동시에 처리하도록 하는 것이다. 

멀티 스레딩을 할 경우 스레드간 Stack영역을 제외한 메모리를 공유하고 있기 때문에 스레드 간 작업량이 작아`Context-Switching`이 빠르며 자원을 효율적으로 관리할 수 있다. 또한 통신의 부담이 적어 응답시간이 빠르다. 

하지만 스레드 하나가 프로세스 내 자원을 망친다면 전체 프로세스에게 영향을 받게 된다. 또한 스레드 간에 전역변수로 자원을 공유하기 때문에 필연적으로 동기화 문제가 발생할 수 밖에 없다. 스레드의 스케줄링은 운영체제가 자동으로 해주지 않기 때문에 프로그래머의 주의 깊은 설계가 필요하며 디버깅 또한 까다로워진다.

<br>

## ✨ 자바 래퍼 클래스란? 자동 박싱과 자동 언박싱이 일어나는 경우는? 

> https://coding-factory.tistory.com/547

### 래퍼 클래스(Wrapper Class)란?

자바의 **8개의 기본 자료 타입을 객체로 다루기 위해 사용하는 클래스**들을 `래퍼 클래스(Wrapper Class)`라고 한다. 래퍼 클래스는 각각의 타입에 해당하는 데이터를 인수로 전달받아 해당 값을 가지는 객체로 만들어 준다. 래퍼클래스로 감싸고 있는 기본 타입 값은 외부에서 변경할 수 없으며, 만약 값을 변경하고 싶다면 새로운 포장 객체를 만들어야 한다. 모든 래퍼클래스의 부모는 `Object`이며 final 클래스로 정의된다.

| 기본 타입(Primitive Type) | 래퍼 클래스 (Wrapper Class) |
| :------------------------ | :-------------------------- |
| byte                      | Byte                        |
| char                      | Character                   |
| int                       | Integer                     |
| float                     | Float                       |
| double                    | Double                      |
| boolean                   | Boolean                     |
| long                      | Long                        |
| short                     | Short                       |

<br>

### 박싱(Boxing) 과 언박싱(UnBoxing)

![img](https://blog.kakaocdn.net/dn/38MsL/btqEbRcxIfZ/fOMbL4b3wCzqeO1aKKbFZ0/img.png)

기본 타입의 데이터를 래퍼클래스의 인스턴스로 변환하는 과정을 `박싱(Boxing)`이라고 한다. 반대로 래퍼 클래스의 인스턴스에 저장된 값을 다시 기본 타입의 데이터로 꺼내는 과정을 `언박싱(UnBoxing)`이라고 한다.

<br>

### 자동 박싱(AutoBoxing) 과 자동 언박싱(AutoUnBoxing)

JDK 1.5부터 박싱과 언박싱이 필요한 상황에서 자바 컴파일러가 이를 자동으로 처리해준다. 오토 박싱을 이용하면 new 키워드를 사용하지 않고도 자동으로 인스턴스를 생성할 수 있으며, 오토 언박싱을 이용하여 인스턴스에 저장된 값을 바로 참조할 수 있다.

~~~java
Integer i = new Integer(18);	//박싱
int ii = i.intValue();			//언박싱

Character ch = 'A';				//오토박싱
char c = ch;					//오토언박싱
~~~

래퍼클래스와 기본타입의 비교연산도 오토 언박싱을 통해 가능하지만, 래퍼클래스간 동등 연산자를 이용한 비교는 인스턴스에 저장된 값을 비교하는 것이 아니라 객체의 주소값을 비교하므로 항상 false를 반환한다. 그러므로 인스턴스에 저장된 값의 동등 여부는 equals() 메소드를 이용하여야 한다.

<br>

## ✨ 싱글톤 패턴(Singleton Pattern)

> https://gmlwjd9405.github.io/2018/07/06/singleton-pattern.html
>
> https://gem1n1.tistory.com/96
>
> https://medium.com/webeveloper/%EC%8B%B1%EA%B8%80%ED%84%B4-%ED%8C%A8%ED%84%B4-singleton-pattern-db75ed29c36

<br>

### 싱글톤 패턴

싱글턴 패턴은 인스턴스가 오직 1개만 생성되야 하는 경우에 사용되는 패턴이다. 하나의 인스턴스를 메모리에 등록해서 여러 스레드가 동시에 해당 인스턴스를 공유하여 사용하게끔 할 수 있기 때문에 불필요한 메모리 누수를 방지하며 요청이 많은 곳에서 사용하면 효율을 높일 수 있다.

주로 데이터베이스에서 커넥션 풀, 스레드 풀, 캐시, 로그 기록 객체 등을 만들 때 싱글톤 패턴을 이용한다.



### 자바의 싱글톤 패턴

자바에서의 싱글톤 패턴은 클래스 로더에 의해 구현되며 어플리케이션 runtime시 단 한번만 인스턴스화 한다. 공통적인 특징은 `private constructor`로 외부에서 클래스의 인스턴스를 생성할 수 없게 하고, 인스턴스 참조는 `static method`로 정의하여 어느 영역에서든 접근 가능하도록 한다는 점이다.

가장 보편적인 구현 방법은 LazyHolder 방법이며, 제안한 개발자의 이름을 따서 Bill Pugh 구현법이라고도 불린다. 클래스 안에 클래스(holder)를 두어 JVM의 클래스 로더 매커니즘과 클래스가 로드되는 시점을 이용한 방법이다.

~~~JAVA
public class JavaSingleton  
{ 
  private JavaSingleton(){}
  
  private static class BillPughSingleton{ 
    private static final JavaSingleton instance = new JavaSingleton(); 
  } 
  
  public static JavaSingleton getInstance(){ 
    return BillPughSingleton.instance; 
  } 
} 
~~~



### 스프링의 싱글톤 패턴

스프링에서의 싱글톤 패턴은 클래스 자체에 의해서가 아니라, 스프링 컨테이너에 의해 구현된다. 스프링은 bean을 등록할 때 범위를 지정할 수 있는 기본이 싱글턴이며 그 외에도 prototype, request, session이 있다. 스프링 컨테이너 내에서 `Bean`이 정의되면 스프링 컨테이너는 그 클래스에 대해 딱 한개의 인스턴스를 만든다. 이 공유 인스턴스는 설정 정보에 의해 관리되고 bean이 호출될 때 마다 스프링은 생성된 공유 인스턴스를 리턴시킨다.

공유 인스턴스의 생성 시점은 스프링 컨테이너에 따라 달라진다. bean 팩토리는 최초 호출 시점에서 인스턴스를 생성하고, 어플리케이션 컨텍스트는 미리 모든 공유 인스턴스를 다 초기화 해두었다가 호출될 때 바로 리턴시켜준다. bean 관리 주체인 스프링 컨테이너는 그 어떤 호출에도 단일 공유 인스턴스를 리턴시키므로 `thread safety`도 자동으로 보장된다.