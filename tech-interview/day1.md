# 💣day1 (2021/01/12)

<br>

### static과 private 메소드 오버라이딩을 할수 있는가?

static, final, private 지정자를 가진 메소드는 오버라이딩이 불가능합니다.

static 메소드는 클래스 메소드로서 컴파일 과정에서 결합되기때문에 java단에서 재정의 할 수 없습니다.

final 키워드는 엔티티를 한번만 할당합니다. 즉, 변경이 불가능하다는 것 입니다. 예를 들어 final 클래스는 해당 클래스를 상속해서 사용할 수 없다는 것을 의미하고, final 메소드의 경우 하위 클래스에서 오버라이딩 할 수 없음을 의미합니다. private 접근 제한자는 현재 클래스 내에서만 접근이 허용되므로 오버라이딩 할 수 없습니다. private메소드는 오버라이딩 할 수 없기에 final을 따로 명시하지 않아도 final의 개념을 가지고 있다고 할 수 있습니다.

오버라이딩은 상속받은 메소드를 하위클래스에서 재정의 하여 사용하는 것 입니다. 오버라이딩 하기 위해선 메소드의 이름과, 메소드 매개변수의 개수와 데이터 타입, 순서가 같아야하며 메소드의 리턴 타입이 모두 동일해야합니다. 개발자의 철자에 대한 실수 등을 방지하기 위해 @Override 어노테이션을 사용합니다.

<br>

### String, String Buffer, StringBuilder의 차이점

`String`은 final 클래스로서 변경 불가능(immutable)한 속성을 가졌습니다. 한번 생성된 String인스턴스가 갖고 있는 문자열은 읽어 올 수만 있고 변경할 수 없습니다.  문자열을 결합하는 경우 인스턴스 내의 문자열이 바뀌는 것이 아니라 결합할 때마다 새로운 문자열을 생성하기 때문에 메모리 공간을 비교적 많이 차지하게 됩니다. 

`StringBuffer`는 내부적으로 문자열 편집을 위한 버퍼를 가지고 있습니다. 인스턴스를 생성할 때 크기를 지정할 수 있어 적절한 char형 배열이 생성되고, 이 배열은 문자열을 저장하고 편집하기 위한 공간으로 사용됩니다. 크기를 지정하지 않는다면 16개의 문자를 저장할 수 있는 크기의 버퍼를 생성합니다.

 `StringBuffer`는 멀티쓰레드에 안전하도록 동기화되어 있습니다. 멀티쓰레드로 작성된 프로그램이 아닐 경우 불필요한 동기화는 성능 저하만 유발합니다. 이를 해결하기 위해 `StringBuffer`에서 동기화 기능을 빼고 고안된 것이 `StringBuilder` 입니다. 완전히 똑같은 기능으로 작성되어 있기 때문에 생성자만 바꾸어 동일하게 사용할 수 있습니다.

즉 `String`과 `StringBuffer`는 불변과 가변의 차이, `StringBuffer`와 `StringBuilde`는 동기화 여부에 대한 차이가 있습니다.

<br>

### static메소드에서 non-static 에 접근할수있는가?

없습니다.

static 멤버는 클래스당 하나가 생성되는 것으로 클래스 로딩시에 별도의 공간에 생성되기때문에 클래스멤버라고도 부릅니다. non-static 멤버는 객체마다 별도로 존재하여 객체 생성시에 생성되기 때문에 인스턴스 멤버라고도 부릅니다. static 메소드는 객체 없이 존재하기 때문에 객체와 함께 생성되는 non-static 멤버를 사용할 수 없고, static 멤버만 사용할 수 있습니다. 반면 non-static 메소드는 static 멤버를 사용할 수 있습니다.

<br>

### http와 https의 차이점

`HTTP`는 하이퍼 텍스트 전송 프로토콜로, 서로 다른 시스템들 사이에서 통신을 주고받게 해주는 가장 기초적인 프로토콜입니다. `HTTP`의 문제점은 서버에서부터 브라우저로 전송되는 정보(단순 텍스트)가 암호화 되지 않기 때문에 데이터가 도난당할 수 있는 점입니다. 이 문제를 보안 소켓인 `SSL`을 사용함으로서 해결한 것이 `HTTPS`(하이퍼 텍스트 전송 프로토콜 보안)입니다. `HTTPS`의 S가 `Secure Socket(보안 통신망)`을 의미하며 HTTP에 데이터 암호화가 추가된 프로토콜입니다. HTTPS는 SSL과 같은 프로토콜을 사용하여 공개키/개인키 기반으로 데이터를 압호화 합니다.