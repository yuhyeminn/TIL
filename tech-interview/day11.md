# 💣day0 (2021/00/00)

<br>

## ✨ CI/CD

>https://itholic.github.io/qa-cicd/
>
>https://velog.io/@makeitcloud/%EB%9E%80-CI-Continuous-Integration-CD-Continuous-Deployment-%EB%9E%80
>
>https://devuna.tistory.com/56

<br>

### CI/CD

- **애플리케이션 개발 단계를 자동화**하여 애플리케이션을 보다 **짧은 주기로 고객에게 제공**하는 방법
- 애플리케이션의 통합 및 테스트 단계에서부터 제공 및 배포에 이르는 애플리케이션의 **라이프사이클 전체에 걸쳐 지속적인 자동화와 지속적인 모니터링**을 제공
- 이러한 구축 사례를 일반적으로 "CI/CD 파이프라인"이라 부르며 **개발 및 운영의 애자일 방식 협력**을 통해 지원
- **지속적인 통합**(Continuous Integration), **지속적인 서비스 제공**(Continuous Delivery), **지속적인 배포**(Continuous Deployment)으로 구성

![img](https://blog.kakaocdn.net/dn/VfH9n/btqEbvA6cjl/x2hYkrLRyfWgNWxfrQkSu0/img.png)

<br>

### CI (Continuous Intergration)

`CI`는 **지속적 통합 (Continuous Intergration)**으로 모든 개발이 끝난 이후에 코드 품질을 관리하는 고전적 방식의 단점을 해소하기 위해 나타난 개념이다. 말 그대로 개발을 하면서 '코드에 대한 통합'을 지속적으로 진행함으로써 품질을 유지하는 것이다.

CI의 핵심 목표는,**버그를 신속하게 찾아 해결하고**,**소프트웨어의 품질을 개선하고**,**새로운 업데이트의 검증 및 릴리즈의 시간을 단축시키는 것**에 있다.

<br>

### CD (Continuous Deploy or Delivery)

`CD`란 **지속적 배포(Continuous Deploy 또는 Delivery)**로써, 소프트웨어가 항상 신뢰 가능한 수준에서 배포될 수 있도록 지속적으로 관리하자는 개념이다. **지속적인 제공(Continuous Delivery)**란 개발자들이 애플리케이션에 적용한 변경 사항이 버그 테스트를 거쳐 레포지토리에 자동으로 업로드되는 것을 뜻한다. 지속적인 제공은 최소한의 노력으로 새로운 코드를 배포하는 것을 목표로 한다.

**지속적인 배포(Continuous Deployment)**란 개발자의 변경 사항을 레포지토리에서 고객이 사용 가능한 프로덕션 환경까지 자동으로 릴리스하는 것을 의미한다. 이는 애플리케이션 제공 속도를 저해하는 수동 프로세스로 인한 운영팀의 프로세스 과부하 문제를 해결한다. 지속적인 배포는 파이프라인의 다음 단계를 자동화함으로써 지속적인 제공이 가진 장점을 활용한다.

<br>

## ✨ 컴파일러와 인터프리터

> https://coding-factory.tistory.com/303

`컴파일러`와 `인터프리터`는 고급 언어로 작성된 원시 프로그램을 목적 프로그램으로 번역하는 번역프로그램이다. 즉,  사용자가 이해할 수 있는 고급 언어로 작성된 소스 코드를 기계가 이해할 수 있는 기계어로 번역하는 것이다.



### 컴파일러(Compiler)

- 컴파일러는 고급 언어로 작성된 프로그램 전체를 목적 프로그램으로 번역한 후, 링킹 작업을 통해 컴퓨터에서 실행 가능한 실행 프로그램을 생성함
- 번역 실행 과정을 거쳐야 하기 때문에 번역 과정이 번거롭고, 번역 시간도 오래 걸리지만 한번 번역한 후에는 다시 번역하지 않으므로 실행 속도가 빠름
- 컴파일러를 사용하는 언어는 C, C++, Java 등이 있음



### 인터프리터(Interpreter)

- 인터프리터는 고급 언어로 작성된 프로그램을 한 줄 단위로 받아들여 번역하고, 번역과 동시에 프로그램을 한 줄 단위로 즉시 실행시키는 프로그램
- 프로그램이 직접 실행되므로 목적 프로그램은 생성되지 않음
- 줄 단위로 번역, 실행되기 때문에 시분할 시스템에 유용하며 원시 프로그램의 변화에 대한 반응이 빠름
- 번역 속도는 빠르지만 프로그램 실행 시 매번 번역해야 하므로 실행 속도가 느림
- 인터프리터를 사용하는 언어는 Python, HTML, JS, Ruby 등이 있음



<br>

## ✨ 쿼리의 속도 및 효율 향상법

> https://medium.com/watcha/%EC%BF%BC%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%B2%AB%EA%B1%B8%EC%9D%8C-%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-7%EA%B0%80%EC%A7%80-%EC%B2%B4%ED%81%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8-bafec9d2c073

<br>

- SELECT 시에는 꼭 필요한 컬럼만 불러와야 함
- 조건 부여시 가급적이면 기존 DB값에 별도의 연산을 걸지 않는 것이 좋음
- LIKE 사용 시 와일드 카드 문자열(%)을 String 앞부분에 배치하지 않는 것이 좋음
- SELECT DISTINCT, UNION DISTINCT와 같이 중복값을 제거하는 연산은 최대한 사용하지 않아야 함
- 같은 내용의 조건이라면, GROUP BY연산 시에는 가급적 HAVING 보다는 WHERE 절을 사용하는 것이 좋음
- 3개 이상의 테이블을 INNER JOIN할 때는, 크기가 가장 큰 테이블을 FROM절에 배치하고, INNER JOIN 절에는 남은 테이블을 작은 순서대로 배치하는 것이 좋음
- 자주 사용하는 데이터의 형식에 대해서는 미리 전처리된 테이블을 따로 보관/관리하는 것도 좋음

<br>

## ✨ 자바의 synchronized 키워드

> https://ktko.tistory.com/entry/%EC%9E%90%EB%B0%94-synchronized%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC

<br>

### synchronized

자바에서 프로그래밍을 한다면 Multi-Thread로 인하여 동기화를 제어해야하는 경우가 생긴다. 그 때 자바에서 제공하는 키워드인` synchronized` 키워드를 사용하게 되는데, **Multi-Thread 상태에서 동일한 자원을 동시에 접근하게 되었을 때 동시 접근을 막게 된다.** 

즉, 공유 데이터에 lock을 걸어서 먼저 작업 중이던 쓰레드가 작업을 완전히 끝낼 때까지는 다른 쓰레드에게 제어권이 넘어가더라도 데이터가 변경되지 않도록 보호함으로써 쓰레드의 동기화를 가능하게 한다.

- 메서드에 synchronized 하기

  ~~~java
  public synchronized void synchronizedTest () {}
  ~~~

  - 인스턴스 메서드의 동기화는 이 메서드를 가진 인스턴스 기준으로 일어남

  - synchronized를 사용한 메서드가 존재한다면 인스턴스당 한 개의 Thread만이 접근할 수 있음
  - **메서드에 synchronized를 사용하면 그 함수가 포함된 객체(this)가 lock이 걸린 것** 

- 블록에 synchronized 하기

  ~~~java
  synchronized([락(Lock) 객체]) {}
  ~~~

  - synchronized 키워드는 공유 자원에 대한 범위를 지정하는 기능을 하며 synchronized() 괄호 안에 있는 락 객체는 다른 스레드의 접근을 차단하거나 접근을 허용하는 일종의 자물쇠 역할을 함
  - 락 객체는 문지기 역할을 해서 오직 하나의 스레드만이 동기화 블록에 접근할 수 있음

  

메서드 제어자 뒤에 synchronized 키워드가 위치한 동기화 메서드는 락 객체를 지정하는 부분이 없다. 동기화 메서드는 내부적으로 자신의 객체를 락으로 사용한다. 즉, 객체 스스로 메서드 전체를 감시하는 역할을 한다. 

이에 반해서 동기화 블록은 메서드 안의 특정 부분을 동기화할 수 있다. 이런 경우에 락 객체는 자기 자신 객체를 의미하는 this 키워드를 사용할 수도 있지만 다른 객체를 락으로 사용할 수 있다. 단, 락 객체가 여러 개라면 우리가 원하는 동기화 작업을 제대로 실행할 수 없기 때문에 락 객체를 하나만 사용하는 경우가 많다. 동기화 블록을 사용하는 경우, 해당 메서드는 여러 스레드가 동시에 점유할 수 있지만 동기화된 블록에 이르면 락 객체에 의해서 모든 스레드들은 실행을 중단하고 자신의 차례가 될 때까지 대기한다.