# 💣day3 (2021/01/14)

<br>

## ✨ REST(RESTful) API

>https://meetup.toast.com/posts/92
>
>https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html

![img](https://gmlwjd9405.github.io/images/network/restapi.png)

### REST란?

`REST`란 **Representational State Transfer** 의 약자로서 **자원의 표현에 의한 상태전달**을 의미한다. 즉, 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태를 주고받는 모든 것을 의미한다. 구체적으로는 **HTTP URI(Uniform Resource Identifier)를 통해 자원을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation를 적용하는 것**을 의미한다. REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다.

즉, REST는 자원 기반의 구조(ROA, Resource Oriented Architecture) 설계의 중심에 Resource가 있고 HTTP Method를 통해 Resource를 처리하도록 설계된 아키텍쳐를 의미한다.

<br>

### REST 구성요소

- **자원(Resource)**
  - 모든 자원에는 고유 ID가 존재하며 이 자원은 서버에 존재함.
  - 자원을 구별하는 ID는 'groups/:group_id'와 같은 URI
- **행위(Verb)**
  - HTTP의 **GET, POST, PUT, DELETE** 등 HTTP Method 사용
- **표현(Representation)**
  - 클라이언트의 요청에 대한 서버의 적절한 응답(Represeatation)
  - REST에서 하나의 자원은 JSON, XML, TEXT, RSS 등 여러 형태로 표현될 수 있음

<br>

### REST API

`REST API`란 REST기반으로 서비스 API를 구현한 것이다. `API`란 데이터와 기능의 집합을 제공하여 컴퓨터 프로그램간 상호작용을 촉진하며, 서로 정보를 교환 가능하도록 하는 것이다.  

REST는 HTTP 표준을 기반으로 구현하므로, HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다.

<br>

### REST API 설계 기본 규칙

> - 도큐먼트 : 객체 인스턴스나 데이터베이스 레코드와 유사 개념
> - 컬렉션 : 서버에서 관리하는 디렉터리 리소스
> - 스토어 : 클라이언트에서 관리하는 리소스 저장소

1. URI는 정보의 자원을 표현해야 한다.

   - 자원은 동사보다 명사, 대문자보다 소문자를 사용
   - 자원의 도큐먼트 이름으로는 단수 명사 사용
   - 자원의 컬렉션 이름으로는 복수 명사를 사용
   - 자원의 스토어 이름으로는 복수 명사 사용

   ~~~ 
   EX)
   http://restapi.example.com/sports/soccer
   http://restapi.example.com/sports/soccer/players/13
   ~~~

2. 자원에 대한 행위는 HTTP Method(GET, PUT, POST, DELETE)로 표현한다.

   - URI에 행위에 대한 동사 표현이 들어가면 안됨
     - EX ) `GET /members/show/1` -> `GET /members/1`
   - 경로 부분 중 변하는 부분은 유일한 값으로 대체
     - EX ) id가 10인 member 삭제 -> `DELETE /students/12`

<br>

### REST API 설계 규칙

1. 슬래시 구분자(/)는 계층 관계를 나타내는 데에 사용

2. URI 마지막 문자로 슬래시(/)를 포함하지 않음

3. 하이픈(-)은 URI 가독성을 높이는 데 사용

4. 밑줄(_)은 URI에 사용하지 않음

5. URI 경로는 소문자가 적합함

   - RFC 3986(URI 문법 형식)은 URI 스키마와 호스트를 제외하고는 대소문자를 구별하도록 규정함

6. 파일 확장자는 URI에 포함하지 않음

   - Accept header를 사용하여 파일 확장자를 명시

7. 리소스 간에 연관관계가 있는 경우

   - /리소스명/리소스ID/관계가 있는 다른 리소스명

     ~~~ 
     GET : /users/{userId}/devices
     ~~~

   - 관계명이 복잡하다면 서브 리소스에 명시적으로 표현

     ~~~
     GET : /users/{userId}/likes/devices
     ~~~

### HTTP 응답 상태 코드

잘 설계된 REST API는 URI만 잘 설계된 것이 아닌 그 리소스에 대한 응답을 잘 내어주는 것 까지 포함되어야 한다. 정확한 응답의 상태코드만으로도 많은 정보를 전달할 수 있기 때문에 상태코드 값을 명확히 돌려주는 것은 생각보다 중요하다.

- 1XX : 전송 프로토콜 수준의 정보 교환
- 2XX : 클라이언트 요청이 성공적으로 수행됨
  - `200` : 클라이언트의 요청을 정상적으로 수행함
  - `201` : 클라이언트가 어떠한 리소스 생성을 요청, 해당 리소스가 성공적으로 생성됨(POST를 통한 리소스 생성 작업 시)
- 3XX : 클라이언트는 요청을 완료하기 위해 추가적인 행동을 취해야 함
  - `301` : 클라이언트가 요청한 리소스에 대한 UIR가 변경되었을 때 사용하는 응답코드
- 4XX : 클라이언트의 잘못된 요청
  - `400` : 클라이언트의 요청이 부적절 할 경우 사용하는 응답 코드
  - `401` : 클라이언트가 인증되지 않은 상태에서 보호된 리소스를 요청했을 때 사용하는 응답코드
  - `403` : 유저 인증상태와 관계 없이 응답하고 싶지 않은 리소스를 클라이언트가 요청했을 때 사용하는 응답코드
  - `405` : 클라이언트가 요청한 리소스에서는 사용 불가능한 Method를 이용했을 경우 사용하는 응답코드
- 5XX : 서버 쪽 오류로 인한 상태코드
  - `500` : 서버에 문제가 있을 경우 사용하는 응답코드

<br>

### RESTful이란?

일반적으로 REST라는 아키텍처를 구현하는 웹서비스를 나타내기 위해 사용되는 용어이다. 즉, REST API를 제공하는 웹 서비스를 RESTful하다고 할 수 있으며 REST의 원리를 따르는 시스템은 RESTful이란 용어로 지칭된다.

RESTful한 API를 구현하는 근본적인 목적이 성능 향상에 있는 것이 아니라 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것이 주 동기이니, 성능이 중요한 상황에서는 굳이 RESTful한 API를 구현할 필요는 없다.

<br>

## ✨ JVM과 JVM 메모리 구조에 대해 설명

> https://jeong-pro.tistory.com/148

<br>

### JVM(Java Virtual Machine)이란?

자바 가상머신으로 자바 바이트 코드를 실행할 수 있는 주체이다.  JAVA와 플랫폼 사이에서 중개자 역할을 하여 JAVA가 플랫폼에 종속적이지 않고 독립적으로 실행될 수 있도록 해준다. 즉, 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 플랫폼이 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 한다. 그리고 가장 중요한 메모리관리와 가비지 컬렉션을 수행한다.

### JVM 메모리 영역 - Runtime Data Area

Runtime Data Area 는 JVM의 메모리 영역으로 자바 어플리케이션을 실행할 때 사용되는 데이터들을 적재한다. 이 영역은 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다.

![img](https://t1.daumcdn.net/cfile/tistory/9973563D5ACE031521)

- Method Area (메소드 영역)
  - 클래스 멤버 변수의 이름, 데이터타입, 접근제어자 정보같은 필드 정보와 메소드 정보, Type 정보, Constant Pool(상수 풀), static 변수, final class 변수 등이 생성되는 영역
- Heap Area(힙 영역)
  - new 키워드로 생성된 객체와 배열이 생성되는 영역
  - 메소드 영역에 로드된 클래스만 생성이 가능하고, GC가 참조되지 않는 메모리를 확인하고 제거하는 영역
- Stack Area(스택 영역)
  - 지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값 등이 생성되는 영역
  - 예를들어 `Person p = new Person();`이라는 소스를 작성했다면 Person p는 스택영역에, new로 생성된 Person 객체는 힙영역에 생성됨. 스택 영역의 p가 힙 영역에 생성된 객체를 참조함
  - 메소드 호출 시 마다 각각의 스택이 생성됨
- PC Register(PC 레지스터)
  - 쓰레드가 생성될 때 마다 생성되는 영역. 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장함
- Native method stack
  - 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역
  - 보통 C/C++ 코드를 수행하기 위한 스택

<br>

## ✨ 가비지 컬렉션

> https://madplay.github.io/post/java-garbage-collection

#### 가비지(Garbage)란 ?

가비지란 무효영역이라고도 하며 **더이상 사용되지 않는 메모리**를 뜻한다. 자바의 `new`연산자를 이용하여 시스템으로부터 힙 영역 메모리를 할당받아 사용되어지다가 더이상 사용되지 않는 객체나 배열 등이 가비지에 해당된다. 더이상 사용되지 않는다는 것은 객체나 배열을 가리키는 레퍼런스가 하나도 없음을 의미한다.

#### 가비지 컬렉션(Garbage Collection)

가비지를 회수하여 사용할 수 있는 메모리 공간을 늘리는 작업을 가비지 컬렉션이라고 한다. 그리고 이러한 일을 수행하는 것을 가비지 컬렉터라고 한다.

자바에선 JVM이 가비지 컬렉션 스레드를 두고 있어 가비지 컬렉션을 수행하기 때문에 별도의 객체를 해제할 필요가 없다. JVM의 내부적 알고리즘 판단으로 수행되기 때문에 정확히 언제 일어나는지는 알기 어렵다.

<br>

## ✨ 큐(Queue)와 스택(Stack)

- `큐(Queue)` : 가장 먼저 저장된 데이터를 먼저 꺼내는 `선입선출(FIFO)`구조
  
  - 큐는 최근 사용 문서, 인쇄 작업 대기 목록, 버퍼 등의 기능을 구현할 때 활용됨
  
  - 자바에서 큐 메모리 구조는 별도의 인터페이스 형태로 제공됨
    - Deque 인터페이스를 구현한 LinkedList 클래스가 큐 메모리 구조를 구현하는 데 가장 많이 사용됨
  - 메소드
    - add : 큐에 객체 저장
    - offer : 큐에 객체 저장
    - poll : 큐에서 데이터를 꺼냄
    - peek : 큐에서 데이터를 꺼내지 않고 읽어옴

<br>

- `스택(Stack)` : 마지막에 저장된 데이터가 먼저 나오는 `후입선출(LIFO)` 구조
  
  - 스택은 수식계산이나 워드프로세서의 undo/redo, 또는 웹브라우저의 뒤로/앞으로와 같은 기능들을 구현할 때 활용됨
  
  - 자바에서 스택 클래스를 제공함
  - 메소드
    - push : 스택에 객체 저장
    - pop : 스택에서 맨 위에 저장된 객체를 꺼냄
    - peek : 스택에서 맨 위에 저장된 객체를 꺼내지 않고 읽어옴