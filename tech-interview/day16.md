# 💣day16 (2021/02/10)

<br>

## ✨ 웹사이트에 접속하는 과정

>https://heekim0719.tistory.com/297#footnote_link_297_1

<br>

1. url 주소를 입력한다
2. 입력된 주소는 브라우저 내부에서 갖고 있는 규칙에 따라 의미를 조사한다
   - 브라우저가 URL 주소 중 도메인 네임을 DNS 서버에 검색함
   - Local DNS에 해당 IP주소가 존재한다면 바로 응답함
   - 그렇지 않을 경우 Root DNS부터 순차적으로 재귀적 질의를 통해 IP주소를 찾아 응답함
3. 브라우저는 조사를 토대로 request 메세지를 작성한다.
4. 운영체제에 내장된 네트워크 제어 소프트웨어인 Protocol Stack이 브라우저로부터 request 메세지를 받는다.
5. Protocol Stack은 패킷에 메세지를 저장하고 제어정보를 붙인다.
   - Protocol Stack은 일종의 매니저라고 생각하면 이해가 쉽다,
6. Protocol Stack이 패킷을 LAN 어댑터에 넘겨주고, LAN 어댑터는 패킷을 전기신호로 변환시킨다.
7. 변환된 전기 신호를 LAN 케이블에 송출한다.
8. 송신된 패킷은 스위칭 허브를 경유하여 인터넷 접속용 라우터에 도착한다.
9. 라우터는 패킷을 통신사에 전달하고 이로써 인터넷에 들어가게 된다.
10. 패킷은 인터넷 입구의 통신 회선에 의해 통신사용 라우터까지 운반된다.
11. 통신사용 라우터를 거쳐 인터넷 핵심부로 들어가면 수많은 고속 라우터 사이로 목적지까지 향한다.
12. 웹 서버측의 LAN에 도착하면 웹 서버의 방화벽은 패킷을 검사하고, 검사가 끝나면 캐시 서버가 웹 서버에 들어가야할지를 판단하고 캐시 서버에 존재하는 내용일 경우 바로 값을 가져와 빠르게 돌려보낸다.
13. 캐시 서버에 존재하지 않을 경우 웹 서버로 들어간다.
14. 웹 서버의 Protocol Stack이 패킷을 추출하여 패킷 내에 들어있는 request 메세지를 복원한다.
15. Protocol Stack이 이 메세지를 웹 서버 Application에 전달한다.
16. 웹 서버 Application이 주는 응답 메세지를 받아 Protocol Stack은 같은 방식으로 다시 목적지를 향해 전달한다.

<br>

## ✨ 다중 서버 환경에서 세션을 관리하는 방법

> https://juyoung-1008.tistory.com/2
>
> https://hyuntaeknote.tistory.com/6
>
> https://junshock5.tistory.com/84
>
> https://velog.io/@tjdrnr0557/Multi-Server%EC%97%90%EC%84%9C-Session-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95-Sticky-Session-Session-Clustering-Redis-Session-Storage

### 세션(Session)이란?

`세션(Session)`은 클라이언트와 웹서버 간 네트워크 연결이 지속 유지되고 있는 상태를 말한다. 즉, 사용자가 브라우저를 열어 서버에 접속한 뒤 접속을 종료할 때까지의 시점을 말한다. HTTP 프로토콜은 비접속형 프로토콜이므로, 매 접속마다 새로운 네트워크 연결이 이루어지는데 세션이 연결 유지를 가능하게 한다.

클라이언트가 웹서버에 Request를 보내면 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는데, 이를 세션ID라고 한다. 세션ID는 임시로 저장하여 페이지 이동 시 이용하거나, 클라이언트가 재접속 했을 때 클라이언트를 유일하게 구분하는 수단이 된다. 정보들이 서버단에 저장되기 때문에 보안 면에서 쿠키보다 우수하다.



### 다중 서버 환경에서 세션을 관리하는 방법

> - Sticky Session
> - Session Clustering
> - Inmemory DB를 이용한 세션 storage

### Stickey Session

 `Stickey Session`은 말 그대로 고정된 세션을 의미한다. `Load Balance`가 기본적으로 라운드 로빈 방식으로 트래픽을 분산하며,  이 Stickey Session의 핵심은 로드 밸런스가 얼마나 오랫동안 동일한 인스턴스로 사용자 요청을 일관되게 라우팅 하도록 하느냐 이다. 즉, **특정 사용자가 접속을 시도했을 때 처음 접속된 서버로 계속해서 접속되도록 트래픽을 처리하는 방식이다.**

![img](https://blog.kakaocdn.net/dn/boFlh4/btqESXc9LPa/c6j2klIYPLK1ni9QAmXLUk/img.png)

 예를들어, `User1`이 1번부터 3번까지의 서버 중 1번 서버에 세션을 생성하였다면, 이후에 User1이 보내는 모든 요청은 Load Balancer에 의해 리다이렉트되어 1번 서버로만 보내지게 된다. 이를 위해 로드 밸런서는 요청을 받으면 가장 먼저 요청에 쿠키가 존재하는지 확인하고, 쿠키가 있다면 지정된 서버로 전송된다. 쿠키가 없는경우 기존 로드밸런싱 알고리즘 기반으로 서버를 선정한다.

 Stickey Session 방식을 이용하면 사용자는 세션이 유지되는 동안 동일한 서버만을 사용하기 때문에 정합성 이슈에서 자유로워질 수 있다. 하지만 고정된 세션을 사용한다는 것은 특정 서버에 트래픽이 집중될 위험이 있기 때문에 자신의 서버에 트래픽이 집중되어있더라도 다른 서버를 사용할 수 없다. 또한 하나의 서버에 장애가 발생한다면 해당 서버를 사용하는 사용자들은 세션 정보를 잃게 되어 가용성이 떨어진다.



### 세션 클러스터링 (Session Clustering)

 Stickey Session을 이용하면 정합성 이슈를 해결할 수 있지만 가용성과 트래픽 분산을 완벽히 확보할 수 없다. Session Clustering은 정합성 이슈를 해결하면서 가용성과 트래픽 분산까지 확보 할 수 있는 세션 관리 방식이다.

 `Clustering`이란 여러 대의 컴퓨터들이 하나의 시스템처럼 동작하도록 만드는 것이다. `Session Clustering`은 WAS가 2대 이상 설치 형태일 때 동일한 세션으로 관리하는 것을 의미한다.

![img](https://blog.kakaocdn.net/dn/beH7KU/btqESih0Ula/6QwZUMToYxOh8j1LLIwYdK/img.png)

 세션을 복제하면 유저가 이후에 어떤 서버에 접속하더라도 데이터가 세션에 복제되어 있으므로 정합성 이슈가 해결된다. 하지만 모든 서버가 동일한 세션 객체를 가져야하기 때문에 많은 메모리가 필요하다. 또한 세션 저장소에 저장될 때마다 모든 서버에 입력해야 하므로 트래픽 증가로 인해 서버수가 증가할 때 성능 저하가 발생하게 된다. 이보다 가장 치명적인 단점은 여러 대의 서버로 하나의 서비스를 위해 사용함으로써 데이터 불일치가 잠재적으로 발생할 수 있다. Session Clustering은 가용성과 트래픽 분산을 이용할 수 있지만 세션 저장소를 저장할 때마다 성능적 한계가 명확하다.

 

### 세션 스토리지 분리(Inmemory DB)

 세션 스토리지 분리란 기존 서버가 갖고있는 세션 저장소를 이용하는 것이 아니라, 별도의 세션 저장소를 사용하여 세션 스토리지를 분리하는 것이다. Inmemory DB란 데이터 스토리지의 메인 메모리에 설치되어 운영되는 방식의 데이터베이스 시스템이다. 메모리 접근이 디스크 접근보다 빠르며 데이터를 조회할 때 검색 시간이 줄어든다. 대표적으로 Redis와 Memcached가 있다.

![img](https://blog.kakaocdn.net/dn/cvGZ64/btqESWyzU7U/wPLINLrekwoSehSrteRLa0/img.png)

 위와 같이 세션 스토리지가 분리되면 서버가 아무리 늘어난다고 할 지라도 세션 스토리지에 대한 정보만 각각의 서버에 입력해주면 세션을 공유할 수 있게된다. 이러한 방식을 사용한다면 트래픽이 비정상적으로 몰리는 현상을 고려하지 않아도 되고, 서버 하나가 장애가 발생하더라도 별도의 세션 저장소가 존재하기 때문에 가용성을 확보할 수 있다. 뿐만 아니라 여러 대의 서버가 하나의 세션을 이용하기 때문에 개별적으로 갖고있던 로컬 세션 저장소의 데이터 불일치가 발생하지 않는다. 단, 하나의 세션 저장소를 운영하는 것은 해당 세션 저장소에 장애가 발생하면 모든 세션이 이용 불가하기 때문에 복제를 구성하는 것이 좋다.

<br>

## ✨ ElasticSearch의 키워드 검색과 RDBMS에서 %LIKE% 검색

> [[엘라스틱서치 알아보기 #2] DB만 있으면 되는데, 왜 굳이 검색엔진?](https://velog.io/@jakeseo_me/%EC%97%98%EB%9D%BC%EC%8A%A4%ED%8B%B1%EC%84%9C%EC%B9%98-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-2-DB%EB%A7%8C-%EC%9E%88%EC%9C%BC%EB%A9%B4-%EB%90%98%EB%8A%94%EB%8D%B0-%EC%99%9C-%EA%B5%B3%EC%9D%B4-%EA%B2%80%EC%83%89%EC%97%94%EC%A7%84)
>
> https://victorydntmd.tistory.com/308

<br>

### ElasticSearch

Elasticsearch는 Apache Lucene( 아파치 루씬 ) 기반의 Java 오픈소스 분산 검색 엔진이다. Elasticsearch를 통해 루씬 라이브러리를 단독으로 사용할 수 있게 되었으며, 방대한 양의 데이터를 신속하게, 거의 실시간( NRT, Near Real Time )으로 저장, 검색, 분석할 수 있다.

### 검색 엔진이 필요한 이유

- **관계형 데이터베이스는 단순 텍스트 매칭에 대한 검색만 제공**
  - 요즘 MYSQL 최신 버전에서는 n-gram 기반의 Full-text 검색을 지원하지만 한글 검색의 경우에 아직 많이 빈약함
- **ES는 텍스트를 여러 단어로 변형하거나 텍스트의 특징을 이용한 동의어나 유의어를 활용한 검색이 가능**
- ES에는 관계형 데이터베이스에서 불가능한 비정형 데이터의 색인과 검색이 가능
- ES에는 형태소 분석을 통한 자연어 처리가 가능
- 역색인 지원으로 매우 빠른 검색이 가능



<br>

## ✨ 자바에서 Mutable 객체와 Immutable 객체의 차이점

> https://sup2is.github.io/2020/01/29/java-immutable-object-with-string.html

<br>

### 가변(Mutable) 객체

- 클래스의 인스턴스가 생성된 이후에도 내부 상태 변경이 가능한 객체
- **객채 내의 특정 요소를 변경** **할 수 있는 객체를** **mutable 객체**
- List, ArrayList, HashMap
- VO(Value Object) 객체, StringBuilder, StringBuffer

### 불변(Immutable) 객체

- 클래스의 인스턴스가 생성된 시점부터 내부 상태가 일정하게 유지되는 객체
- **객체 내의 특정 요소의 값을 변경 할 수 없는 객체**
- multi-thread 환경에서 안전함
- 객체 자체가 변경에 폐쇄적인 상태로 설계되어야 할 경우 불변객체로 선언
- String class
  - 한 번 생성된 String 객체는 + 연산자 등의 변경을 시도하려는 행위를 해도 최초 생성된 객체 자체가 변경되지 않음.



